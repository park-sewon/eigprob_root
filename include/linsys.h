#ifndef LINSYS_H
#define LINSYS_H
 
#include "iRRAM/lib.h"
#include "iRRAM/core.h"
#include "polynomial.h"
#include "complexmatrix.h"

#include <utility>
using namespace iRRAM;


REAL trace(REALMATRIX );
REALMATRIX power(REALMATRIX , int );
void print(REALMATRIX );

REAL inner(REALMATRIX , REALMATRIX );
REALMATRIX colVector(REALMATRIX , int );


//********************************************//
// X = concat(A, B)                           //
//Given two matrices A, B with same number of //
//rows, it returns new matrix X = [A,B]       //
//********************************************//
REALMATRIX concat(REALMATRIX , REALMATRIX );


//********************************************//
// P = linearSys(A, b)                        //
//Given a square matrix A, return the         //
//characteristic polynomial of A.             //
//if b == true, it processes the trace method //
//otherwise, it processes the interpolating   //
//method. if b is not provided, it processes  //
//the trace method.                           //
//********************************************//
POLYNOMIAL charPoly(REALMATRIX );
POLYNOMIAL charPoly(REALMATRIX , bool );
POLYNOMIAL HermitianCharPoly(COMPLEXMATRIX);

//********************************************//
// X = linearSys(A, B)                        //
//Given a square matrices A and a matrix  B   //
//with same mumber of rows, return a matrix X //
//such that AX = B. The process doesn't       //
//terminate if A is not a matrix of full rank //
//********************************************//
REALMATRIX linearSys(REALMATRIX , REALMATRIX );


//********************************************//
// x = linearSys(A)                           //
//Given a regular square matrix A, return     //
//its determinant x                           //
//********************************************//
REAL determinant(REALMATRIX );

//********************************************//
// Y = inv(X)                                 //
//Given a square matrix X, return the inverse //
//matrix of X. The process doesnt terminate if//
//X is singular                               //
//********************************************//
REALMATRIX inv(REALMATRIX );


//********************************************//
// V = VSimilar(A)                            //
// Given a square matrix A, return a similar  //
// matrix V generated by a Vandermonde matrix //
// of 1,2,...,dim(A)                          //
//Given two square matrices A, B with same    //
//********************************************//
REALMATRIX VSimilar(REALMATRIX );


//********************************************//
// X = eigenVector(A, e, k)                   //
//Given a square matrix A, one of its eigen   //
//value e, the dimension of its eigenspace,   //
//return a matrix X composed of 			  //
//orthonomal column vectors (basis)			  //
//of the eigenvectors                         //
//********************************************//
REALMATRIX eigenVector(REALMATRIX , REAL , int );


//********************************************//
// P = dianomalize(A, k)                      //
//Given a square matrix A and k the number of //
//disinct eigenvalues of the matrix A, return //
//eigen vector matrix P such that P-1AP is a  //
//diagonal simialr matrix of A.               //
//********************************************//
REALMATRIX diagonalizeNaive(REALMATRIX , int );
REALMATRIX diagonalizeTrisection(REALMATRIX , int );
REALMATRIX diagonalizeNewton(REALMATRIX , int );
REALMATRIX diagonalizeCombined(REALMATRIX , int );
REALMATRIX diagonalizeBounded(REALMATRIX , int );
COMPLEXMATRIX HermitianDiagonalizeBounded(COMPLEXMATRIX , int );

//********************************************//
// [P,v] = dianomalize(A, k)                  //
//Given a square matrix A and k the number of //
//disinct eigenvalues of the matrix A, return //
//a vector of pairs of eigenvalues and        //
//corresponding eigenspace's orthonomal basis //
//********************************************//
std::vector<std::pair< REALMATRIX, REAL> > 
diagonalizeNaiveEig(REALMATRIX , int );
std::vector<std::pair< REALMATRIX, REAL> > 
diagonalizeTrisectionEig(REALMATRIX , int );
std::vector<std::pair< REALMATRIX, REAL> > 
diagonalizeNewtonEig(REALMATRIX , int );
std::vector<std::pair< REALMATRIX, REAL> > 
diagonalizeCombinedEig(REALMATRIX , int );
std::vector<std::pair< REALMATRIX, REAL> > 
diagonalizeBoundedEig(REALMATRIX , int );
std::vector<std::pair< COMPLEXMATRIX, REAL> > 
HermitianDiagonalizeBoundedEig(COMPLEXMATRIX , int );

// Offer a transpose matrix
REALMATRIX transpose(REALMATRIX );

// Offer a transpose matrix
COMPLEXMATRIX transpose(COMPLEXMATRIX );



// Return a random orthogonal matrix 
// where the distribution over a orthogonal matrix group is a Haar measure: uniform measure.
REALMATRIX HaarMeasure(int );

// Return normalized QR decomposition of a regular matrix: X = QR with X (input) regular, R upper triangle, Q (output) orthogonal.
// When each entry of X is gaussian normal distributed i.i.d, resulting Q follows Haar measure. 
REALMATRIX QRDecomposition(REALMATRIX );



#endif
